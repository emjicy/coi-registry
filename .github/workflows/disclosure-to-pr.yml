name: Convert Disclosure Issues to PRs

on:
  issues:
    types: [opened, labeled, edited]

permissions:
  contents: write        # to push branch
  pull-requests: write   # to open PR
  issues: read           # to read issue body
  actions: read

jobs:
  issue_to_pr:
    if: |
      github.event.issue != null &&
      (
        contains(github.event.issue.labels.*.name, 'disclosure') ||
        (github.event.action == 'opened' && contains(github.event.issue.title, '[Disclosure]'))
      )
    runs-on: ubuntu-latest

    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          persist-credentials: false  # we'll push with a token below
          fetch-depth: 0

      - name: Set up Node
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Parse issue ➜ update registry.json ➜ open PR
        id: convert
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const core = require('@actions/core');
            const {context, github} = require('@actions/github');
            const owner = context.repo.owner;
            const repo  = context.repo.repo;
            const issue = context.payload.issue;

            // --- helpers ---
            function pickLabel(name) {
              return (issue.labels || []).some(l => (l.name||'').toLowerCase() === name.toLowerCase());
            }

            function mdVal(line) {
              // extract after **field:** pattern or "- key: value"
              const m1 = line.match(/^\*\*([^*]+)\*\*:\s*(.+)$/);
              if (m1) return {key: m1[1].trim(), val: m1[2].trim()};
              const m2 = line.match(/^\-\s*([A-Za-z0-9_]+)\s*:\s*(.+)$/);
              if (m2) return {key: m2[1].trim(), val: m2[2].trim()};
              return null;
            }

            function cleanBackticksCommaList(s) {
              if (!s) return [];
              return s
                .split(',')
                .map(x => x.trim().replace(/^`|`$/g,''))
                .filter(Boolean);
            }

            function parseLinksCSV(s) {
              if (!s) return [];
              // Accept <url>, bare urls, comma-separated
              return s.split(',')
                .map(x => x.trim().replace(/^<|>$/g,''))
                .filter(Boolean);
            }

            // --- parse issue body (generated by the website form) ---
            const lines = (issue.body || '').split(/\r?\n/);

            const parsed = {
              delegate_id: '',
              display_name: '',
              organization: '',
              wallets: [],
              interest: {
                type: '',
                project: '',
                role: '',
                interest_type: '',
                materiality: '',
                status: '',
                compensation_currency: '',
                org_affiliation: '',
                time: { start_date: '', ongoing: undefined },
                disclosure: { short_text: '', links: [] },
                links: []
              }
            };

            let inInterest = false, inTime = false, inDisclosure = false;

            for (const raw of lines) {
              const line = raw.trim();

              // Section toggles (robust to minor formatting differences)
              if (/^\*\*interest/i.test(line) || /^interest\s*:/i.test(line)) { inInterest = true; continue; }
              if (/^\-\s*time\s*:/.test(line)) { inTime = true; continue; }
              if (/^\-\s*disclosure\s*:/.test(line)) { inDisclosure = true; continue; }

              const kv = mdVal(line);
              if (!kv) continue;
              const k = kv.key.toLowerCase().replace(/\s+/g,'_');
              const v = kv.val;

              if (!inInterest) {
                if (k === 'delegate_id') parsed.delegate_id = v;
                else if (k === 'display_name') parsed.display_name = v;
                else if (k === 'organization') parsed.organization = v;
                else if (k === 'wallets') parsed.wallets = cleanBackticksCommaList(v);
              } else {
                if (inTime) {
                  if (k === 'start_date') parsed.interest.time.start_date = v;
                  else if (k === 'ongoing') {
                    parsed.interest.time.ongoing = (v.toLowerCase() === 'yes') ? true : (v.toLowerCase() === 'no' ? false : undefined);
                  }
                } else if (inDisclosure) {
                  if (k === 'short_text') parsed.interest.disclosure.short_text = v;
                  else if (k === 'links') parsed.interest.disclosure.links = parseLinksCSV(v);
                } else {
                  if (k === 'type') parsed.interest.type = v.toLowerCase();
                  else if (k === 'project') parsed.interest.project = v;
                  else if (k === 'role') parsed.interest.role = v;
                  else if (k === 'interest_type') parsed.interest.interest_type = v;
                  else if (k === 'materiality') parsed.interest.materiality = v;
                  else if (k === 'status') parsed.interest.status = v;
                  else if (k === 'compensation_currency') parsed.interest.compensation_currency = v;
                  else if (k === 'org_affiliation') parsed.interest.org_affiliation = v;
                  else if (k === 'links') parsed.interest.links = parseLinksCSV(v);
                }
              }
            }

            // Basic validation
            if (!parsed.delegate_id || !parsed.interest.project || !parsed.interest.type) {
              core.setFailed('Missing required fields: delegate_id, interest.type, interest.project');
              return;
            }
            if (!['direct','indirect'].includes(parsed.interest.type)) {
              core.setFailed(`interest.type must be "direct" or "indirect" (received: ${parsed.interest.type})`);
              return;
            }

            // --- load current registry.json from main ---
            const mainRef = 'heads/main';
            const getRef = await github.rest.git.getRef({ owner, repo, ref: mainRef });

            let fileSha = null, registry = null, contentB64 = null;
            try {
              const file = await github.rest.repos.getContent({
                owner, repo, path: 'registry.json', ref: 'main'
              });
              fileSha = file.data.sha;
              contentB64 = file.data.content;
              const buf = Buffer.from(contentB64, 'base64').toString('utf8');
              registry = JSON.parse(buf);
            } catch (e) {
              // If not found, initialize a skeleton
              if (e.status === 404) {
                registry = { version: '1.0.0', generated_at: new Date().toISOString(), maintainer: '', delegates: [] };
              } else {
                throw e;
              }
            }

            // --- upsert delegate ---
            const delegates = registry.delegates || (registry.delegates = []);
            let del = delegates.find(d => (d.id||'').toLowerCase() === parsed.delegate_id.toLowerCase());
            if (!del) {
              del = {
                id: parsed.delegate_id,
                display_name: parsed.display_name || parsed.delegate_id,
                organization: parsed.organization || '',
                contacts: {},
                wallets: parsed.wallets || [],
                compliance: 'compliant',
                notes: '',
                last_updated: new Date().toISOString(),
                interests: { direct: [], indirect: [] }
              };
              delegates.push(del);
            } else {
              // merge wallets
              const existing = new Set((del.wallets || []).map(w => w.toLowerCase()));
              for (const w of (parsed.wallets || [])) {
                const wl = (w||'').toLowerCase();
                if (wl && !existing.has(wl)) { (del.wallets ||= []).push(w); existing.add(wl); }
              }
              del.last_updated = new Date().toISOString();
              del.display_name = del.display_name || parsed.display_name || parsed.delegate_id;
              del.organization = del.organization || parsed.organization || '';
              del.interests = del.interests || { direct: [], indirect: [] };
            }

            // --- build new interest record ---
            const rec = {
              project: parsed.interest.project,
              project_slug: parsed.interest.project.toLowerCase().replace(/[^a-z0-9]+/g,'-').replace(/^\-+|\-+$/g,''),
              role: parsed.interest.role || '',
              interest_type: parsed.interest.interest_type || '',
              materiality: parsed.interest.materiality || '',
              status: parsed.interest.status || '',
              compensation_currency: parsed.interest.compensation_currency || '',
              org_affiliation: parsed.interest.org_affiliation || undefined,
              time: {
                start_date: parsed.interest.time.start_date || '',
                ongoing: typeof parsed.interest.time.ongoing === 'boolean' ? parsed.interest.time.ongoing : undefined
              },
              disclosure: {
                short_text: parsed.interest.disclosure.short_text || '',
                links: parsed.interest.disclosure.links || []
              },
              links: parsed.interest.links || []
            };

            // push into correct array
            const bucket = parsed.interest.type === 'direct' ? 'direct' : 'indirect';
            (del.interests[bucket] ||= []).push(rec);

            // bump top-level generated_at
            registry.generated_at = new Date().toISOString();

            // --- write updated registry to a new branch ---
            const newBranch = `disclosure/issue-${issue.number}`;
            // create ref from main
            await github.rest.git.createRef({
              owner, repo,
              ref: `refs/heads/${newBranch}`,
              sha: getRef.data.object.sha
            });

            // put file
            const newContent = Buffer.from(JSON.stringify(registry, null, 2) + '\n', 'utf8').toString('base64');
            await github.rest.repos.createOrUpdateFileContents({
              owner, repo, branch: newBranch, path: 'registry.json',
              message: `Add disclosure from issue #${issue.number} (${parsed.delegate_id} → ${parsed.interest.project})`,
              content: newContent,
              sha: fileSha || undefined,
              committer: { name: 'coi-bot', email: 'coi-bot@users.noreply.github.com' },
              author: { name: context.actor, email: `${context.actor}@users.noreply.github.com` }
            });

            // --- open PR ---
            const prTitle = `Add disclosure: ${parsed.delegate_id} → ${parsed.interest.project} (from #${issue.number})`;
            const prBody  = `Automated PR created from disclosure issue #${issue.number}.\n\n- Delegate: **${parsed.delegate_id}**\n- Type: **${parsed.interest.type}**\n- Project: **${parsed.interest.project}**`;
            const pr = await github.rest.pulls.create({
              owner, repo,
              title: prTitle,
              head: newBranch,
              base: 'main',
              body: prBody
            });

            core.setOutput('pr_url', pr.data.html_url);

            // --- comment back on the issue ---
            await github.rest.issues.createComment({
              owner, repo, issue_number: issue.number,
              body: `Thanks! I created a PR for this disclosure: ${pr.data.html_url}`
            });

            // --- add tracking label on the issue (optional) ---
            try {
              await github.rest.issues.addLabels({
                owner, repo, issue_number: issue.number,
                labels: ['auto-pr']
              });
            } catch (e) {}
      - name: Show PR URL
        run: echo "PR = ${{ steps.convert.outputs.pr_url }}"
