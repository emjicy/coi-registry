name: Convert Disclosure Issues to PRs

on:
  issues:
    types: [opened, labeled, edited]

permissions:
  contents: write         # push branch / update file via API
  pull-requests: write    # open PRs
  issues: write           # comment and add labels

jobs:
  issue_to_pr:
    if: |
      github.event.issue != null &&
      (
        contains(github.event.issue.labels.*.name, 'disclosure') ||
        (github.event.action == 'opened' && contains(github.event.issue.title, '[Disclosure]'))
      )
    runs-on: ubuntu-latest

    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          persist-credentials: false
          fetch-depth: 0

      - name: Set up Node
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Parse issue ➜ update registry.json ➜ open PR
        id: convert
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            // Use injected globals: core, context, github
            const { owner, repo } = context.repo;
            const issue = context.payload.issue;

            // --- helpers ---
            const mdVal = (line) => {
              const m1 = line.match(/^\*\*([^*]+)\*\*:\s*(.+)$/);
              if (m1) return { key: m1[1].trim(), val: m1[2].trim() };
              const m2 = line.match(/^\-\s*([A-Za-z0-9_]+)\s*:\s*(.+)$/);
              if (m2) return { key: m2[1].trim(), val: m2[2].trim() };
              return null;
            };

            const cleanBackticksCommaList = (s) =>
              (!s ? [] : s.split(',').map(x => x.trim().replace(/^`|`$/g,'')).filter(Boolean));

            const parseLinksCSV = (s) =>
              (!s ? [] : s.split(',').map(x => x.trim().replace(/^<|>$/g,'')).filter(Boolean));

            // --- parse issue body (generated by website form) ---
            const lines = (issue.body || '').split(/\r?\n/);

            const parsed = {
              delegate_id: '',
              display_name: '',
              organization: '',
              wallets: [],
              interest: {
                type: '',
                project: '',
                role: '',
                interest_type: '',
                materiality: '',
                status: '',
                compensation_currency: '',
                org_affiliation: '',
                time: { start_date: '', ongoing: undefined },
                disclosure: { short_text: '', links: [] },
                links: []
              }
            };

            let inInterest = false, inTime = false, inDisclosure = false;

            for (const raw of lines) {
              const line = raw.trim();

              if (/^\*\*interest/i.test(line) || /^interest\s*:/i.test(line)) { inInterest = true; continue; }
              if (/^\-\s*time\s*:/.test(line)) { inTime = true; continue; }
              if (/^\-\s*disclosure\s*:/.test(line)) { inDisclosure = true; continue; }

              const kv = mdVal(line);
              if (!kv) continue;
              const k = kv.key.toLowerCase().replace(/\s+/g,'_');
              const v = kv.val;

              if (!inInterest) {
                if (k === 'delegate_id') parsed.delegate_id = v;
                else if (k === 'display_name') parsed.display_name = v;
                else if (k === 'organization') parsed.organization = v;
                else if (k === 'wallets') parsed.wallets = cleanBackticksCommaList(v);
              } else if (inTime) {
                if (k === 'start_date') parsed.interest.time.start_date = v;
                else if (k === 'ongoing') parsed.interest.time.ongoing =
                  (v.toLowerCase() === 'yes') ? true : (v.toLowerCase() === 'no' ? false : undefined);
              } else if (inDisclosure) {
                if (k === 'short_text') parsed.interest.disclosure.short_text = v;
                else if (k === 'links') parsed.interest.disclosure.links = parseLinksCSV(v);
              } else {
                if (k === 'type') parsed.interest.type = v.toLowerCase();
                else if (k === 'project') parsed.interest.project = v;
                else if (k === 'role') parsed.interest.role = v;
                else if (k === 'interest_type') parsed.interest.interest_type = v;
                else if (k === 'materiality') parsed.interest.materiality = v;
                else if (k === 'status') parsed.interest.status = v;
                else if (k === 'compensation_currency') parsed.interest.compensation_currency = v;
                else if (k === 'org_affiliation') parsed.interest.org_affiliation = v;
                else if (k === 'links') parsed.interest.links = parseLinksCSV(v);
              }
            }

            // Basic validation
            if (!parsed.delegate_id || !parsed.interest.project || !parsed.interest.type) {
              core.setFailed('Missing required fields: delegate_id, interest.type, interest.project');
              return;
            }
            if (!['direct','indirect'].includes(parsed.interest.type)) {
              core.setFailed(`interest.type must be "direct" or "indirect" (received: ${parsed.interest.type})`);
              return;
            }

            // --- load current registry.json from main ---
            const mainRef = 'heads/main';
            const getRef = await github.rest.git.getRef({ owner, repo, ref: mainRef });

            let fileSha = null, registry = null;
            try {
              const file = await github.rest.repos.getContent({
                owner, repo, path: 'registry.json', ref: 'main'
              });
              fileSha = file.data.sha;
              const buf = Buffer.from(file.data.content, 'base64').toString('utf8');
              registry = JSON.parse(buf);
            } catch (e) {
              if (e.status === 404) {
                registry = { version: '1.0.0', generated_at: new Date().toISOString(), maintainer: '', delegates: [] };
              } else {
                throw e;
              }
            }

            // --- upsert delegate ---
            const delegates = registry.delegates || (registry.delegates = []);
            let del = delegates.find(d => (d.id||'').toLowerCase() === parsed.delegate_id.toLowerCase());
            if (!del) {
              del = {
                id: parsed.delegate_id,
                display_name: parsed.display_name || parsed.delegate_id,
                organization: parsed.organization || '',
                contacts: {},
                wallets: parsed.wallets || [],
                compliance: 'compliant',
                notes: '',
                last_updated: new Date().toISOString(),
                interests: { direct: [], indirect: [] }
              };
              delegates.push(del);
            } else {
              const existing = new Set((del.wallets || []).map(w => (w||'').toLowerCase()));
              for (const w of (parsed.wallets || [])) {
                const wl = (w||'').toLowerCase();
                if (wl && !existing.has(wl)) { (del.wallets ||= []).push(w); existing.add(wl); }
              }
              del.last_updated = new Date().toISOString();
              del.display_name = del.display_name || parsed.display_name || parsed.delegate_id;
              del.organization = del.organization || parsed.organization || '';
              del.interests = del.interests || { direct: [], indirect: [] };
            }

            // --- new interest record ---
            const rec = {
              project: parsed.interest.project,
              project_slug: parsed.interest.project.toLowerCase().replace(/[^a-z0-9]+/g,'-').replace(/^\-+|\-+$/g,''),
              role: parsed.interest.role || '',
              interest_type: parsed.interest.interest_type || '',
              materiality: parsed.interest.materiality || '',
              status: parsed.interest.status || '',
              compensation_currency: parsed.interest.compensation_currency || '',
              org_affiliation: parsed.interest.org_affiliation || undefined,
              time: {
                start_date: parsed.interest.time.start_date || '',
                ongoing: typeof parsed.interest.time.ongoing === 'boolean' ? parsed.interest.time.ongoing : undefined
              },
              disclosure: {
                short_text: parsed.interest.disclosure.short_text || '',
                links: parsed.interest.disclosure.links || []
              },
              links: parsed.interest.links || []
            };

            const bucket = parsed.interest.type === 'direct' ? 'direct' : 'indirect';
            (del.interests[bucket] ||= []).push(rec);

            registry.generated_at = new Date().toISOString();

            // --- write to a new branch (create if missing, else reuse) ---
            const newBranch = `disclosure/issue-${issue.number}`;
            const newRef = `refs/heads/${newBranch}`;
            try {
              await github.rest.git.createRef({
                owner, repo, ref: newRef, sha: getRef.data.object.sha
              });
            } catch (e) {
              if (e.status !== 422) throw e; // 422 = already exists
            }

            const newContent = Buffer.from(JSON.stringify(registry, null, 2) + '\n', 'utf8').toString('base64');
            await github.rest.repos.createOrUpdateFileContents({
              owner, repo, branch: newBranch, path: 'registry.json',
              message: `Add disclosure from issue #${issue.number} (${parsed.delegate_id} → ${parsed.interest.project})`,
              content: newContent,
              sha: fileSha || undefined,
              committer: { name: 'coi-bot', email: 'coi-bot@users.noreply.github.com' },
              author: { name: context.actor, email: `${context.actor}@users.noreply.github.com` }
            });

            // --- open (or find) PR ---
            const prTitle = `Add disclosure: ${parsed.delegate_id} → ${parsed.interest.project} (from #${issue.number})`;
            // Check if a PR from this branch already exists
            const existingPRs = await github.rest.pulls.list({
              owner, repo, state: 'open', head: `${owner}:${newBranch}`, base: 'main'
            });
            let pr;
            if (existingPRs.data.length) {
              pr = existingPRs.data[0];
            } else {
              pr = (await github.rest.pulls.create({
                owner, repo, title: prTitle, head: newBranch, base: 'main',
                body: `Automated PR created from disclosure issue #${issue.number}.`
              })).data;
            }

            core.setOutput('pr_url', pr.html_url);

            await github.rest.issues.createComment({
              owner, repo, issue_number: issue.number,
              body: `Thanks! I created a PR for this disclosure: ${pr.html_url}`
            });

            try {
              await github.rest.issues.addLabels({
                owner, repo, issue_number: issue.number,
                labels: ['auto-pr']
              });
            } catch (e) { /* non-fatal */ }

      - name: Show PR URL
        run: echo "PR = ${{ steps.convert.outputs.pr_url }}"
